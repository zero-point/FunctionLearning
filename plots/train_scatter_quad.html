<!DOCTYPE html>
<!-- Simble scatter chart-->
<meta charset="utf-8">
<link type="text/css" href="./css/bootstrap.min.css" rel="stylesheet">
<link type="text/css" href="./final_style.css" rel="stylesheet">

    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.v2.js"></script>
  <body>
    <div class="jumbotron vertical-center">

        <div class="instructions">
              <p><b id="judgementCount">Judgment 1 out of 40</b><br/>
                Please predict the new points, based on the points that you see.
                <br/> Hit the 'Space' key to check if your choice is correct.
                <br/> Hit the 'Enter' key to submit your final choice and move to the next one.</p>
          </div>
          <div class="container">

            <div class="content">
              <!-- /the chart goes here -->
            </div>

    </div>
    <div style="display:none" id="nextScenarioButton"><center>

      <button type="button" class="btn btn-primary btn-lg" onclick="location.href='test_scatter2.html';"><b>Next</b></button>

    </center></div>



    </div>

    <script>
    const debug_mode = false;
    var submittedPoints = [];    // user judgements (length should be 40 at the end)

    var selection_made = false;
    var circle_size = 4;
    var width = 450
      , height = 450;
    var x,y;

    if (debug_mode) {
      judgementCount = 30;
    }
    else {
      judgementCount = 0;     // how many judgements have been sent
    }

    // EQUATIONS
    function getLinear(x){
      return 2*x+1;
    }

    function quadratic(){
      var positions = Array.apply(null, {length: 30}).map(Number.call, Number);
      var trainX = positions.map(function(x) { return x+1; });
      var trainY = positions.map(function(x) { return x*x ; });  //quadratic
      var data = trainX.map(function(v,i) {return [v, trainY[i]];});
      x = d3.scale.linear()
                .domain([0, d3.max(data, function(d) { return d[0]; })*2])
                .range([ 0, 350 ]);
      var y_max = d3.max(data, function(d) { return d[1]; })
      y = d3.scale.linear()
              .domain([-y_max*0.05, y_max*4])
              .range([ 440, 10 ]);

      return [trainX,trainY]
    }
    var xy = quadratic();
    var trainX = xy[0];
    var trainY = xy[1];
    var train_data = trainX.map(function(v,i) {return [v, trainY[i]];});
    var positions = Array.apply(null, {length: 70}).map(Number.call, Number);
    var actualX = positions.map(function(x) { return x+1; });
    var actualY = positions.map(function(x) { return x*x ; });  //quadratic
    var feed = [];

    var updateData = function (yTest) {

    // SVG BOX

    var chart = d3.select('.content')
  	.append('svg')
  	.attr('width', width)
  	.attr('height', height)
    .attr("style", "outline: 2px solid black;")
    .append('g');

    if (debug_mode) {
      selection_made = true;
    }
    else {
      selection_made = false;
    }

    var testX = trainX;
    var testY = trainY;
    var test_data = train_data;
    if(yTest!=undefined){
      testX.push(trainX.length+trainX[0]);
      testY.push(y.invert(yTest));
      test_data = testX.map(function(v,i) {return [v, testY[i]];});
/*      trainX2 = trainX.map(function(a) { return x(a); });
      trainY2 = trainY.map(function(a) { return y(a); });
      trainY2.push(yTest);
      console.log(trainY2);
      data = trainX2.map(function(v,i) {return [v, trainY2[i]];});
    }
    else {
      console.log("ney");
      trainX2 = trainX.map(function(a) { return x(a); });
      trainY2 = trainY.map(function(a) { return y(a); });
      data = trainX2.map(function(v,i) {return [v, trainY2[i]];});
    }*/
    }

    // PLOTTING DATA

    chart.selectAll("scatter-dots")
      .data(test_data)
      .enter().append("circle")
          .attr("cx", function (d,i) {    return x(d[0]); } )
          .attr("cy", function (d,i) {    return y(d[1]);    })
          .attr("r", circle_size);

    // RED LINE
    var currloc = x(test_data.length+1);
    console.log(currloc);
    var red_line = chart.append("svg:line")
      .attr("id", "redLine")
      .attr("x1", currloc)  //<<== change your code here
      .attr("y1", 0)
      .attr("x2", currloc)  //<<== and here
      .attr("y2", 450)
      .style("stroke-width", 2)
      .style("stroke", "red")
      .style("fill", "none");
    var buffer = chart.append("svg:rect")
      .attr('x', currloc-40)
      .attr('y', 0)
      .style('stroke', '#add8e6')
      .style('fill', 'transparent')
      .attr('width', 80)
      .attr('height', 450)
      .on("click", clicked);

    // for(var i=0; i<feed.length; i++){
    //   chart.append("circle")
    //     .attr("id", "feedback")
    //     .attr("transform", "translate(" + [feed[i][0],feed[i][1]] + ")")
    //     .attr("r", circle_size)
    // }

    // MOVE CIRCLE DEPENDING ON MOUSEMOVE

    var last_circle;
    var cont = d3.select('.content');

    var points = [[d3.max(test_data, function(d) { return x(d[0]+1); }),0],[d3.max(test_data, function(d) { return x(d[0]+1); }),450]];
    var line = d3.svg.line()
        .interpolate("cardinal");
    var drag = d3.behavior.drag()
        .on("drag", dragged);
    var path = chart.append("path")
        .datum(points)
        .attr("d", line);
    var line = chart.append("line");

  function dragged(d) {
    var m = d3.mouse(chart.node()),
      p = closestPoint(path.node(), m);

    d3.select(this)
      .attr("transform", "translate(" + p[0] + "," + p[1] + ")")
  }

  function closestPoint(pathNode, point) {
    var pathLength = pathNode.getTotalLength(),
        precision = 8,
        best,
        bestLength,
        bestDistance = Infinity;

    // linear scan for coarse approximation
    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
      if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
        best = scan, bestLength = scanLength, bestDistance = scanDistance;
      }
    }

    // binary search for precise estimate
    precision /= 2;
    while (precision > 0.5) {
      var before,
          after,
          beforeLength,
          afterLength,
          beforeDistance,
          afterDistance;
      if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
        best = before, bestLength = beforeLength, bestDistance = beforeDistance;
      } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
        best = after, bestLength = afterLength, bestDistance = afterDistance;
      } else {
        precision /= 2;
      }
    }

    best = [best.x, best.y];
    best.distance = Math.sqrt(bestDistance);
    return best;

    function distance2(p) {
      var dx = p.x - point[0],
          dy = p.y - point[1];
      return dx * dx + dy * dy;
    }
  }

  function submitPoint(){}

  var last_sel_circle;
  var close = false;

  function clicked(d, i) {
    if (d3.event.defaultPrevented) return; // dragged
    d3.select(this).on('mousedown.drag', null);
    var coordinates = d3.mouse(d3.select('.content').node());
    var newPoint = coordinates[1];
    if (last_sel_circle != undefined){
      last_sel_circle.remove();
    }
    last_sel_circle = chart.append("circle")
      .attr("transform", "translate(" + [currloc,newPoint] + ")")
      .attr("r", circle_size)
    selection_made = true;

    if(Math.abs(newPoint-y(actualY[30+judgementCount]))<50){
      close = true;
    }

    // SPACE KEY SAVES DATA

    document.onkeyup = function(e) {
          var key = e.keyCode || e.which;
          if (key == 32 && selection_made) {
            console.log("user hit space");
            //submittedPoints.push(svgcoord[1]);
            // submitPoint(svgcoord[1]); // and all the rest, also should be JSON
            // feed.push([x(actualX[30+judgementCount]),y(actualY[30+judgementCount])])
            // d3.select(".content").selectAll("svg").remove();
            // updateData();
            chart.append("circle")
              .attr("id", "feedback")
              .attr("transform", "translate(" + [x(actualX[30+judgementCount]),y(actualY[30+judgementCount])] + ")")
              .attr("r", circle_size)
            buffer = chart.append("svg:rect")
                .attr('x', currloc-40)
                .attr('y', 0)
                .style('stroke', '#add8e6')
                .style('fill', 'transparent')
                .attr('width', 80)
                .attr('height', 450)
                .on("click", clicked);

            console.log("close " + Math.abs(newPoint-y(actualY[30+judgementCount])));
            if(Math.abs(newPoint-y(actualY[30+judgementCount]))<50){
          //    close = true;
            }

          }
          if (key === 13 && selection_made && close) {
            console.log("user hit enter");
            if(judgementCount!=40){
              var svgcoord = coordinates;
              judgementCount += 1;
              document.getElementById('judgementCount').innerHTML = "Judgment "+judgementCount+" out of 40";
              d3.select(".content").selectAll("svg").remove();
              updateData(svgcoord[1]);

          }
          else {
            cont.on("mousemove", function(d){});
            d3.select("#lastCircle").style("opacity", 0);
	          d3.select("#redLine").style("opacity", 0);
            document.getElementById("nextScenarioButton").style="display:inline"; // NextButton to quadratic
          }
        }
      }
  }

  var JSON_output = {"version-id": "1.0","sessionID": "","clientTime":"","condition":"1","trainX":trainX,"trainY":trainY,"judgements": submittedPoints};
  JSON_output.clientTime = Date.now();
//  JSON_output.sessionID = randomString(16);
  console.log(JSON_output);


  function ChunkWs (theChunkUrl,messageCallback) {
      this.chunkUrl = theChunkUrl;
      this.wso = new WebSocket(this.chunkUrl);
      this.wsError = 0;
      this.doneState = 0;
      var self = this; // Can't use 'this' to refer to object inside functions
      this.wso.onmessage = function(event) {
          message = JSON.parse(event.data);
          console.log('received websocket message: ' + message);
          console.log('this: ' + JSON.stringify(self));
          messageCallback(self.doneState,self.wsError,message);
      }

      this.wso.onerror = function(error){
              	    console.log('websocket error detected: ' + JSON.stringify(error));
              	    self.wsError = 1;
      }

      this.sendChunk = function(dataChunk) {
              if(dataChunk['experimentId'] == null) console.error("Requires defined experimentId")
              if(dataChunk['sessionId'] == null) console.error("Requires defined sessionId")
      	    var dataStr = JSON.stringify(dataChunk);
      	    this.wso.send(dataStr);
      	    self.doneState = 1;
      }


  }

  ChunkWs.prototype = {
      constructor: ChunkWs
  }



  function submitPoint(){
      var flWebSocket = new WebSocket("ws://somata.inf.ed.ac.uk/fl/ws");
      flWebSocket.onopen = function() {
        /*Send a small message to the console once the connection is established */
        console.log('Connection open!');
      }

      flWebSocket.onmessage = function(event) {
        message = JSON.parse(event.data);
        console.log('webSocket message: ' + message);
      }

     flWebSocket.onerror = function(error){
       console.log('webSocket error detected: ' + error);
     }

     //judgementCount
     var JSON_output = {"version-id": "1.0","sessionID": "","clientTime":"","condition":"1","trainX":trainX,"trainY":trainY,"judgements": submittedPoint};
     JSON_output.clientTime = Date.now();
    // JSON_output.sessionID = randomString(16);

     flWebSocket.send(JSON.stringify(JSON_output));

    }
    //submitPoint();

}

updateData();






   </script>
  </body>
</html>
