<!DOCTYPE html>
<!-- Simble scatter chart-->
<meta charset="utf-8">
<link type="text/css" href="./css/bootstrap.min.css" rel="stylesheet">
<style>

body {
    font-family: "MuseoSans-300";
    font-size: 18px;
    text-rendering: optimizeLegibility;
     -webkit-font-smoothing: antialiased;
}


.jumbotron{
  padding-top:15px;
  padding-bottom:0;
  margin-bottom:0;
  min-height: 100%;
  min-height: 100vh;
}

.selection {
  fill: steelblue;
  fill-opacity: 1;

}

.container {
    display: -webkit-flexbox;
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -webkit-flex-align: center;
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
    justify-content: center;
}

svg {
 border-radius:6px;
 display: block;
 margin : auto;
 display: inline-block;
}


circle {
fill: steelblue;
}

</style>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.v2.js"></script>
  <body>
    <div class="jumbotron vertical-center">

        <div class="container">
                        <p><b id="judgementCount">Judgment 1 out of 40</b><br/>
                        Please predict the new points, based on  the <br/>points that you can see.
                        <br/>Hit the 'Space' key to submit your choice.</p>
          </div>
          <div class="container">

            <div class="content">
              <!-- /the chart goes here -->
            </div>

    </div>
    <div style="display:none" id="nextScenarioButton"><center>----------<a href="1" class="button"><b>   Next   </b></a>---------</center></div>

    // NextButton to quadratic 

    </div>

    <script>

    var judgementCount = 0;
    var circle_size = 4;

    // EQUATIONS

    function linear(){
      var trainX = Array.apply(null, {length: 30}).map(Number.call, Number);
      var trainX = trainX.map(function(x) { return x+1; });
      var count = 10;
      var trainY = trainX.map(function(x) { count+=1;return x+count*100; });  //linear
      console.log(trainX,trainY);
      var data = trainX.map(function(v,i) {return [v, trainY[i]];});

      var x = d3.scale.linear()
                .domain([0, d3.max(data, function(d) { return d[0]; })*2])
                .range([ 0, 450 ]);

      var y = d3.scale.linear()
              .domain([0, d3.max(data, function(d) { return d[1]; })*2])
              .range([ 450, 0 ]);
      return [trainX,trainY]
    }
    function quadratic(){
      var trainX = Array.apply(null, {length: 30}).map(Number.call, Number);
      var trainX = trainX.map(function(x) { return x+1; });
      var trainY = trainX.map(function(x) { return x * x; });  //quadratic
      var data = trainX.map(function(v,i) {return [v, trainY[i]];});
      var x = d3.scale.linear()
                .domain([0, d3.max(data, function(d) { return d[0]; })*2])
                .range([ 0, 450 ]);

      var y = d3.scale.linear()
              .domain([0, d3.max(data, function(d) { return d[1]; })*2])
              .range([ 450, 0 ]);
      return [trainX,trainY]
    }
    function periodic(){
      var trainX = Array.apply(null, {length: 60}).map(Number.call, Number); //periodic
      trainX = trainX.map(function(x) { return x*5;});
      var trainY = trainX.map(function(x)  {return Math.sin(x* (Math.PI / 180))+1;});
      return [trainX,trainY]
    }
    var xy = linear();
    //var xy = quadratic();
    //var xy = periodic();
    var trainX = xy[0];
    var trainY = xy[1];

    // SCALING

    var width = 450
      , height = 450;
    var data = trainX.map(function(v,i) {return [v, trainY[i]];});
    var x = d3.scale.linear()
              .domain([0, d3.max(data, function(d) { return d[0]; })*2])
              .range([ 0, 350 ]);
    var y_max = d3.max(data, function(d) { return d[1]; })
    var y = d3.scale.linear()
            .domain([-y_max*0.05, y_max*2.5])
            .range([ 490, 10 ]);

    var updateData = function (yTest) {

    // SVG BOX

    var chart = d3.select('.content')
  	.append('svg')
  	.attr('width', width)
  	.attr('height', height)
    .attr("style", "outline: 2px solid black;")
    .append('g');

    if(yTest!=undefined){
      trainX.push(trainX.length+trainX[0]);
      trainY.push(y.invert(yTest));
      data = trainX.map(function(v,i) {return [v, trainY[i]];});
/*      trainX2 = trainX.map(function(a) { return x(a); });
      trainY2 = trainY.map(function(a) { return y(a); });
      trainY2.push(yTest);
      console.log(trainY2);
      data = trainX2.map(function(v,i) {return [v, trainY2[i]];});
    }
    else {
      console.log("ney");
      trainX2 = trainX.map(function(a) { return x(a); });
      trainY2 = trainY.map(function(a) { return y(a); });
      data = trainX2.map(function(v,i) {return [v, trainY2[i]];});
    }*/
    }

    // PLOTTING DATA

    chart.selectAll("scatter-dots")
      .data(data)
      .enter().append("circle")
          .attr("cx", function (d,i) {    return x(d[0]); } )
          .attr("cy", function (d,i) {    return y(d[1]);    })
          .attr("r", circle_size);

    // RED LINE
    var testX = x(data.length+1);
    var red_line = chart.append("svg:line")
      .attr("id", "redLine")
      .attr("x1", testX)  //<<== change your code here
      .attr("y1", 0)
      .attr("x2", testX)  //<<== and here
      .attr("y2", 450)
      .style("stroke-width", 2)
      .style("stroke", "red")
      .style("fill", "none");

    // MOVE CIRCLE DEPENDING ON MOUSEMOVE

    var last_circle;
    var cont = d3.select('.content');
    cont.on("mousemove", function(d){
      var linecoord = d3.mouse(this);
      if (last_circle != undefined){
        last_circle.remove();
      }
      last_circle = chart.append("circle")
        .attr("id", "lastCircle")
        .attr("transform", "translate(" + [testX,linecoord[1]] + ")")
        .attr("r", circle_size)
        .call(drag)
        .on("click", clicked);
      });

    var points = [[d3.max(data, function(d) { return x(d[0]+1); }),0],[d3.max(data, function(d) { return x(d[0]+1); }),450]];
    var line = d3.svg.line()
        .interpolate("cardinal");
    var drag = d3.behavior.drag()
        .on("drag", dragged);
    var path = chart.append("path")
        .datum(points)
        .attr("d", line);
    var line = chart.append("line");

  function dragged(d) {
    var m = d3.mouse(chart.node()),
      p = closestPoint(path.node(), m);

    d3.select(this)
      .attr("transform", "translate(" + p[0] + "," + p[1] + ")")
  }

  function closestPoint(pathNode, point) {
    var pathLength = pathNode.getTotalLength(),
        precision = 8,
        best,
        bestLength,
        bestDistance = Infinity;

    // linear scan for coarse approximation
    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
      if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
        best = scan, bestLength = scanLength, bestDistance = scanDistance;
      }
    }

    // binary search for precise estimate
    precision /= 2;
    while (precision > 0.5) {
      var before,
          after,
          beforeLength,
          afterLength,
          beforeDistance,
          afterDistance;
      if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
        best = before, bestLength = beforeLength, bestDistance = beforeDistance;
      } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
        best = after, bestLength = afterLength, bestDistance = afterDistance;
      } else {
        precision /= 2;
      }
    }

    best = [best.x, best.y];
    best.distance = Math.sqrt(bestDistance);
    return best;

    function distance2(p) {
      var dx = p.x - point[0],
          dy = p.y - point[1];
      return dx * dx + dy * dy;
    }
  }

  function submitPoint(){}

  var last_sel_circle;
  function clicked(d, i) {
    if (d3.event.defaultPrevented) return; // dragged
    d3.select(this).on('mousedown.drag', null);
    var coordinates = d3.mouse(d3.select('.content').node());
    if (last_sel_circle != undefined){
      last_sel_circle.remove();
    }
    last_sel_circle = chart.append("circle")
      .attr("transform", "translate(" + [testX,coordinates[1]] + ")")
      .attr("r", circle_size)

    // SPACE KEY SAVES DATA

    document.onkeyup = function(e) {
          var key = e.keyCode || e.which;
          if (key == 32) {
            console.log("user hit space");
            if(judgementCount!=40){
              var svgcoord = coordinates;
              var y1_max = d3.max(data, function(d) { return d[1]; })
              var y1 = d3.scale.linear()
                      .domain([-y1_max*0.05, y1_max*2])
                      .range([ 450, 0 ]);
              svgcoord[1] = svgcoord[1];
              judgementCount += 1;
              document.getElementById('judgementCount').innerHTML = "Judgment "+judgementCount+" out of 40";
              console.log(svgcoord);

              d3.select(".content").selectAll("svg").remove();
              updateData(svgcoord[1]);
              submitPoint(svgcoord[1]); // and all the rest, also should be JSON
              console.log(svgcoord);
          }
          else {
            cont.on("mousemove", function(d){});
            d3.select("#lastCircle").style("opacity", 0);
	          d3.select("#redLine").style("opacity", 0);
            document.getElementById("nextScenarioButton").style="display:inline";
          }
        }
      }
  }
}
  updateData();

   </script>
  </body>
</html>
