<!DOCTYPE html>
<!-- Simble scatter chart-->
<meta charset="utf-8">
<link type="text/css" href="./css/bootstrap.min.css" rel="stylesheet">
<link type="text/css" href="./final_style.css" rel="stylesheet">
<script type="text/javascript" src="http://mbostock.github.com/d3/d3.v2.js"></script>
  <body>
    <div class="jumbotron vertical-center">

        <div class="instructions">
                        <p><b id="judgementCount">Judgment 1 out of 40</b><br/>
                        Please predict the new points, based on  the <br/>points that you can see.
                        <br/>Hit the 'Space' key to submit your choice.</p>
          </div>
          <div class="container">

            <div class="content">
              <!-- /the chart goes here -->
            </div>

    </div>
    <div style="display:none" id="nextScenarioButton"><center>

      <button type="button" class="btn btn-primary btn-lg" onclick="location.href='test_scatter2.html';"><b>Next</b></button>

    </center></div>



    </div>

    <script>
    const debug_mode = false;
    var submittedPoints = [];    // user judgements (length should be 40 at the end)

    var selection_made = false;
    var circle_size = 4;
    var width = 450
      , height = 450;
    var x,y;

    if (debug_mode) {
      judgementCount = 30;
    }
    else {
      judgementCount = 0;     // how many judgements have been sent
    }

    // EQUATIONS

    function quadratic(){
      var positions = Array.apply(null, {length: 30}).map(Number.call, Number);
      var trainX = positions.map(function(x) { return x+1; });
      var trainY = positions.map(function(x) { return x*x ; });  //quadratic
      var data = trainX.map(function(v,i) {return [v, trainY[i]];});
      x = d3.scale.linear()
                .domain([0, d3.max(data, function(d) { return d[0]; })*2])
                .range([ 0, 350 ]);
      var y_max = d3.max(data, function(d) { return d[1]; })
      y = d3.scale.linear()
              .domain([-y_max*0.05, y_max*4])
              .range([ 440, 10 ]);

      return [trainX,trainY]
    }
    var xy = quadratic();
    //var xy = quadratic();
    //var xy = periodic();
    var trainX = xy[0];
    var trainY = xy[1];
    var data = trainX.map(function(v,i) {return [v, trainY[i]];});

    var updateData = function (yTest) {

    // SVG BOX

    var chart = d3.select('.content')
  	.append('svg')
  	.attr('width', width)
  	.attr('height', height)
    .attr("style", "outline: 2px solid black;")
    .append('g');

    if (debug_mode) {
      selection_made = true;
    }
    else {
      selection_made = false;
    }

    if(yTest!=undefined){
      trainX.push(trainX.length+trainX[0]);
      trainY.push(y.invert(yTest));
      data = trainX.map(function(v,i) {return [v, trainY[i]];});
/*      trainX2 = trainX.map(function(a) { return x(a); });
      trainY2 = trainY.map(function(a) { return y(a); });
      trainY2.push(yTest);
      console.log(trainY2);
      data = trainX2.map(function(v,i) {return [v, trainY2[i]];});
    }
    else {
      console.log("ney");
      trainX2 = trainX.map(function(a) { return x(a); });
      trainY2 = trainY.map(function(a) { return y(a); });
      data = trainX2.map(function(v,i) {return [v, trainY2[i]];});
    }*/
    }

    // PLOTTING DATA

    chart.selectAll("scatter-dots")
      .data(data)
      .enter().append("circle")
          .attr("cx", function (d,i) {    return x(d[0]); } )
          .attr("cy", function (d,i) {    return y(d[1]);    })
          .attr("r", circle_size);

    // RED LINE
    var testX = x(data.length+1);
    console.log(testX);
    var red_line = chart.append("svg:line")
      .attr("id", "redLine")
      .attr("x1", testX)  //<<== change your code here
      .attr("y1", 0)
      .attr("x2", testX)  //<<== and here
      .attr("y2", 450)
      .style("stroke-width", 2)
      .style("stroke", "red")
      .style("fill", "none");
    var buffer = chart.append("svg:rect")
      .attr('x', testX-40)
      .attr('y', 0)
      .style('stroke', '#add8e6')
      .style('fill', 'transparent')
      .attr('width', 80)
      .attr('height', 450)
      .on("click", clicked);

    // MOVE CIRCLE DEPENDING ON MOUSEMOVE

    var last_circle;
    var cont = d3.select('.content');

    var points = [[d3.max(data, function(d) { return x(d[0]+1); }),0],[d3.max(data, function(d) { return x(d[0]+1); }),450]];
    var line = d3.svg.line()
        .interpolate("cardinal");
    var drag = d3.behavior.drag()
        .on("drag", dragged);
    var path = chart.append("path")
        .datum(points)
        .attr("d", line);
    var line = chart.append("line");

  function dragged(d) {
    var m = d3.mouse(chart.node()),
      p = closestPoint(path.node(), m);

    d3.select(this)
      .attr("transform", "translate(" + p[0] + "," + p[1] + ")")
  }

  function closestPoint(pathNode, point) {
    var pathLength = pathNode.getTotalLength(),
        precision = 8,
        best,
        bestLength,
        bestDistance = Infinity;

    // linear scan for coarse approximation
    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
      if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
        best = scan, bestLength = scanLength, bestDistance = scanDistance;
      }
    }

    // binary search for precise estimate
    precision /= 2;
    while (precision > 0.5) {
      var before,
          after,
          beforeLength,
          afterLength,
          beforeDistance,
          afterDistance;
      if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
        best = before, bestLength = beforeLength, bestDistance = beforeDistance;
      } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
        best = after, bestLength = afterLength, bestDistance = afterDistance;
      } else {
        precision /= 2;
      }
    }

    best = [best.x, best.y];
    best.distance = Math.sqrt(bestDistance);
    return best;

    function distance2(p) {
      var dx = p.x - point[0],
          dy = p.y - point[1];
      return dx * dx + dy * dy;
    }
  }

  function submitPoint(){}

  var last_sel_circle;
  function clicked(d, i) {
    if (d3.event.defaultPrevented) return; // dragged
    d3.select(this).on('mousedown.drag', null);
    var coordinates = d3.mouse(d3.select('.content').node());
    console.log(coordinates);

    if (last_sel_circle != undefined){
      last_sel_circle.remove();
    }
    last_sel_circle = chart.append("circle")
      .attr("transform", "translate(" + [testX,coordinates[1]] + ")")
      .attr("r", circle_size)
    selection_made = true;

    // SPACE KEY SAVES DATA

    document.onkeyup = function(e) {
          var key = e.keyCode || e.which;
          if (key == 32 && selection_made) {
            console.log("user hit space");
            if(judgementCount!=40){
              var svgcoord = coordinates;
              var y1_max = d3.max(data, function(d) { return d[1]; })
              var y1 = d3.scale.linear()
                      .domain([-y1_max*0.05, y1_max*2])
                      .range([ 450, 0 ]);
              svgcoord[1] = svgcoord[1];
              judgementCount += 1;
              document.getElementById('judgementCount').innerHTML = "Judgment "+judgementCount+" out of 40";
              console.log(svgcoord);

              d3.select(".content").selectAll("svg").remove();
              submittedPoints.push(svgcoord[1]);
          //    submitPoint(svgcoord[1]); // and all the rest, also should be JSON
              console.log(svgcoord);
              updateData(svgcoord[1]);

          }
          else {
            cont.on("mousemove", function(d){});
            d3.select("#lastCircle").style("opacity", 0);
	          d3.select("#redLine").style("opacity", 0);
            document.getElementById("nextScenarioButton").style="display:inline"; // NextButton to quadratic
          }
        }
      }
  }

  var JSON_output = {"version-id": "1.0","sessionID": "","clientTime":"","condition":"1","trainX":trainX,"trainY":trainY,"judgements": submittedPoints};
  JSON_output.clientTime = Date.now();
//  JSON_output.sessionID = randomString(16);
  console.log(JSON_output);


  function ChunkWs (theChunkUrl,messageCallback) {
      this.chunkUrl = theChunkUrl;
      this.wso = new WebSocket(this.chunkUrl);
      this.wsError = 0;
      this.doneState = 0;
      var self = this; // Can't use 'this' to refer to object inside functions
      this.wso.onmessage = function(event) {
          message = JSON.parse(event.data);
          console.log('received websocket message: ' + message);
          console.log('this: ' + JSON.stringify(self));
          messageCallback(self.doneState,self.wsError,message);
      }

      this.wso.onerror = function(error){
              	    console.log('websocket error detected: ' + JSON.stringify(error));
              	    self.wsError = 1;
      }

      this.sendChunk = function(dataChunk) {
              if(dataChunk['experimentId'] == null) console.error("Requires defined experimentId")
              if(dataChunk['sessionId'] == null) console.error("Requires defined sessionId")
      	    var dataStr = JSON.stringify(dataChunk);
      	    this.wso.send(dataStr);
      	    self.doneState = 1;
      }


  }

  ChunkWs.prototype = {
      constructor: ChunkWs
  }



  function submitPoint(){
      var flWebSocket = new WebSocket("ws://somata.inf.ed.ac.uk/fl/ws");
      flWebSocket.onopen = function() {
        /*Send a small message to the console once the connection is established */
        console.log('Connection open!');
      }

      flWebSocket.onmessage = function(event) {
        message = JSON.parse(event.data);
        console.log('webSocket message: ' + message);
      }

     flWebSocket.onerror = function(error){
       console.log('webSocket error detected: ' + error);
     }

     //judgementCount
     var JSON_output = {"version-id": "1.0","sessionID": "","clientTime":"","condition":"1","trainX":trainX,"trainY":trainY,"judgements": submittedPoint};
     JSON_output.clientTime = Date.now();
    // JSON_output.sessionID = randomString(16);

     flWebSocket.send(JSON.stringify(JSON_output));

    }
    //submitPoint();

}

updateData();






   </script>
  </body>
</html>
